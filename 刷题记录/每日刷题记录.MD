# leetcode 每日刷题记录
<!-- MarkdownTOC -->

- [2018.4.11](#2018411)
    - [771. 宝石与石头](#771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4)
    - [595.大的国家](#595%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6)
    - [182. 寻找重复的电子邮箱:注意 having 子句的使用](#182-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E6%B3%A8%E6%84%8F-having-%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8)
    - [657. 判断路线成圈](#657-%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88)
    - [175. 组合两个表：注意left join 后的条件使用 on](#175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%EF%BC%9A%E6%B3%A8%E6%84%8Fleft-join-%E5%90%8E%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BD%BF%E7%94%A8-on)
- [2018.4.12](#2018412)
    - [476. 数字的补数](#476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0)
    - [557. 反转字符串中的单词 III](#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii)
    - [728. 自除数](#728-%E8%87%AA%E9%99%A4%E6%95%B0)
    - [804. 唯一摩尔斯密码词](#804-%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D)
    - [292. Nim游戏](#292-nim%E6%B8%B8%E6%88%8F)
    - [183. 从不订购的客户](#183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7)
    - [181. 超过经理收入的员工](#181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5)
    - [561. 数组拆分 I](#561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-i)
    - [303. 区域和检索 - 不可变](#303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2---%E4%B8%8D%E5%8F%AF%E5%8F%98)
    - [746. 使用最小花费爬楼梯](#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF)
    - [647. 回文子串](#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2)
- [2018.4.13](#2018413)
    - [64. 最小路径和](#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C)
    - [35. 搜索插入位置](#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE)
    - [349.两个数组的交集](#349%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86)
    - [744. 寻找比目标字母大的最小字母](#744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D)
    - [367. 有效的完全平方数](#367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0)
    - [374. 猜数字大小:需要深入理解](#374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%E9%9C%80%E8%A6%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)
    - [278. 第一个错误的版本](#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC)
- [2018.4.14](#2018414)
    - [378. 有序矩阵中第K小的元素：优先队列（最大堆，lambda表达式）](#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E6%9C%80%E5%A4%A7%E5%A0%86%EF%BC%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89)
    - [230. 二叉搜索树中第K小的元素：前序遍历](#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86)
    - [718. Maximum Length of Repeated Subarray：动态规划，构建二维数组](#718-maximum-length-of-repeated-subarray%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%9E%84%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84)
    - [392. 判断子序列: 双指针](#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8F%8C%E6%8C%87%E9%92%88)
- [2018.4.15](#2018415)
    - [38. 报数](#38-%E6%8A%A5%E6%95%B0)
    - [520. 检测大写字母](#520-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D)
    - [788. 旋转数字](#788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97)
- [2018.4.16](#2018416)
    - [345. 反转字符串中的元音字母](#345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D)
    - [551. 学生出勤纪录 I](#551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95-i)
    - [67. 二进制求和](#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C)
    - [74. 搜索二维矩阵](#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5)
    - [153. 寻找旋转排序数组中的最小值](#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC)
- [2018.4.18](#2018418)
    - [541. 反转字符串 II](#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii)
    - [58. 最后一个单词的长度](#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6)
    - [459. 重复的子字符串](#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2)
- [2018.4.19](#2018419)
    - [696. 计数二进制子串](#696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2)
    - [819. Most Common Word](#819-most-common-word)
    - [521. 最长特殊序列 Ⅰ](#521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%A0)
    - [606. 根据二叉树创建字符串](#606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)
    - [434. 字符串中的单词数](#434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0)
    - [287. 寻找重复数](#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)
    - [209. 大于给定和最短子数组](#209-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%92%8C%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84)
    - [485. 最大连续1的个数](#485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0)
    - [566. 重塑矩阵](#566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5)
    - [383. 赎金信](#383-%E8%B5%8E%E9%87%91%E4%BF%A1)
    - [28. 实现strStr\(\)](#28-%E5%AE%9E%E7%8E%B0strstr)
- [2018.4.24](#2018424)
    - [154. 寻找旋转排序数组中的最小值 II](#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-ii)
    - [27. 移除元素](#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0)
    - [141. 环形链表](#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8)
    - [142. 环形链表 II](#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii)
- [2018.4.25](#2018425)
    - [从排序数组中删除重复项 II](#%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9-ii)
    - [763. 划分字母区间](#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4)
    - [56. 合并区间](#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4)
    - [713. Subarray Product Less Than K](#713-subarray-product-less-than-k)
- [2018.4.26](#2018426)
    - [617. 合并二叉树](#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91)
    - [441. 排列硬币](#441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81)

<!-- /MarkdownTOC -->



<a id="2018411"></a>
# 2018.4.11

<a id="771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4"></a>
## 771. 宝石与石头
<a id="595%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6"></a>
## 595.大的国家
<a id="182-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E6%B3%A8%E6%84%8F-having-%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8"></a>
## 182. 寻找重复的电子邮箱:注意 having 子句的使用
<a id="657-%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88"></a>
## 657. 判断路线成圈
<a id="175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8%EF%BC%9A%E6%B3%A8%E6%84%8Fleft-join-%E5%90%8E%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BD%BF%E7%94%A8-on"></a>
## 175. 组合两个表：注意left join 后的条件使用 on 


<a id="2018412"></a>
# 2018.4.12 

<a id="476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0"></a>
## 476. 数字的补数
<a id="557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-iii"></a>
## 557. 反转字符串中的单词 III 
<a id="728-%E8%87%AA%E9%99%A4%E6%95%B0"></a>
## 728. 自除数
<a id="804-%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D"></a>
## 804. 唯一摩尔斯密码词
<a id="292-nim%E6%B8%B8%E6%88%8F"></a>
## 292. Nim游戏
<a id="183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7"></a>
## 183. 从不订购的客户
<a id="181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5"></a>
## 181. 超过经理收入的员工
<a id="561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-i"></a>
## 561. 数组拆分 I 
<a id="303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2---%E4%B8%8D%E5%8F%AF%E5%8F%98"></a>
## 303. 区域和检索 - 不可变
<a id="746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"></a>
## 746. 使用最小花费爬楼梯
<a id="647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"></a>
## 647. 回文子串

<a id="2018413"></a>
# 2018.4.13

<a id="64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"></a>
## 64. 最小路径和
<a id="35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"></a>
## 35. 搜索插入位置
<a id="349%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"></a>
## 349.两个数组的交集
<a id="744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D"></a>
## 744. 寻找比目标字母大的最小字母
<a id="367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"></a>
## 367. 有效的完全平方数
<a id="374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F%E9%9C%80%E8%A6%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"></a>
## 374. 猜数字大小:需要深入理解
<a id="278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"></a>
## 278. 第一个错误的版本

<a id="2018414"></a>
# 2018.4.14

<a id="378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E6%9C%80%E5%A4%A7%E5%A0%86%EF%BC%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"></a>
## 378. 有序矩阵中第K小的元素：优先队列（最大堆，lambda表达式）
<a id="230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9A%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"></a>
## 230. 二叉搜索树中第K小的元素：前序遍历
<a id="718-maximum-length-of-repeated-subarray%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%9E%84%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"></a>
## 718. Maximum Length of Repeated Subarray：动态规划，构建二维数组
<a id="392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8F%8C%E6%8C%87%E9%92%88"></a>
## 392. 判断子序列: 双指针

<a id="2018415"></a>
# 2018.4.15


<a id="38-%E6%8A%A5%E6%95%B0"></a>
## 38. 报数
<font color=red >这里面的逻辑有些不太懂，需要重写</font>


### 题目
报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```
1 被读作  "one 1"  ("一个一") , 即 11。

11 被读作 "two 1s" ("两个一"）, 即 21。

21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n ，输出报数序列的第 n 项。

注意：整数顺序将表示为一个字符串。

**示例 1:**
```
输入: 1
输出: "1"
```
**示例 2:**
```
输入: 4 
输出: "1211"
```
### 代码
```java
class Solution {
    public String countAndSay(int n) {
                if (n<=0)
            return null;

        String result ="1";
        int i =1;
        while (i<n){
            StringBuffer sb = new StringBuffer();
            int count =1;
            for (int j=1;j<result.length();j++){
                if (result.charAt(j) == result.charAt(j-1)){
                    count++;
                }
                else {
                    sb.append(count).append(result.charAt(j-1));
                     count =1;
                }
            }
            sb.append(count);
            sb.append(result.charAt(result.length()-1));
            result = sb.toString();
            i++;
        }
        return result;
    }
}
```


<a id="520-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D"></a>
## 520. 检测大写字母

<font color="red">注意区分逻辑即可。注意判断大小写时候的等号</font>

### 题目
给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如"USA"。

 -  单词中所有字母都不是大写，比如"leetcode"。
 - 如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。
 - 否则，我们定义这个单词没有正确使用大写字母。

示例 1:
```
输入: "USA"
输出: True
```
示例 2:
```
输入: "FlaG"
输出: False
```

注意: 输入是由大写和小写拉丁字母组成的非空单词。

### 代码
```java
class Solution {
    public boolean detectCapitalUse(String word) {
                if (word == null)
            return false;
        if (word.length() == 0)
            return true;

        int len = word.length();

        int a_num =0;
        int A_num =0;

        //首字母小写
        if (word.charAt(0)>='a' && word.charAt(0) <='z'){
            for (int i=1;i<len;i++){
                if (word.charAt(i)>='A' && word.charAt(i)<='Z'){
                    return false;
                }
                else {
                    a_num++;
                }
            }
            if (a_num == len-1)
                return true;
        }
        //首字母大写
        else {
            for (int i=1;i<len;i++){
                if (word.charAt(i)>='a' && word.charAt(i) <='z'){
                    a_num++;
                }
                else  {
                    A_num++;
                }
            }
               if (A_num == len-1 || a_num == len-1)
                   return true;
        }

        return false;
    }
}
```
<a id="788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97"></a>
## 788. 旋转数字
<font color="red">参考的别人的博客写的，自己写觉得这里面逻辑复杂，没有完全想明白</font>
### 题目
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？

```
示例:
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
```

注意:

- N 的取值范围是 [1, 10000]。


### 代码
```java
class Solution {
    public int rotatedDigits(int N) {
                if (N<=1)
            return 0;

        String[] flag = {"same","same","valid","invalid","invalid","valid","valid","invalid","same","valid"};

        int count = 0;

        while (N>1){
            int number = N;
            boolean fond = false;   //每一次大循环，fond 都需要跑更新
            while (number != 0){
                int index = number%10;
                if (flag[index] == "invalid"){
                    fond = false;
                    break;
                }
                if (flag[index] == "valid")
                    fond = true;
                number = number/10;

            }

            if (fond)
                count++;
            N--;
        }
        return count;
    }
}
```

<a id="2018416"></a>
# 2018.4.16

<a id="345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D"></a>
## 345. 反转字符串中的元音字母
类型：字符串
### 题目
编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
```
示例 1：
给定 s = "hello", 返回 "holle".

示例 2：
给定 s = "leetcode", 返回 "leotcede".
```
注意:

元音字母不包括 "y".


### 思路
采用双指针和hashset实现，将字符串转换为数组会更加高效

### 代码
```java
class Solution {
    public String reverseVowels(String s) {
               //校验输入
        if (s == null || s.length() == 0)
            return s;

        //将字符串转化为数组
        char[] chars = s.toCharArray();

        //创建 hashset,用于判别
        HashSet<Character> set = new HashSet<>();
        set.add('a');
        set.add('e');
        set.add('i');
        set.add('o');
        set.add('u');
        set.add('A');
        set.add('E');
        set.add('I');
        set.add('O');
        set.add('U');

        int start = 0;
        int end =chars.length-1;

        while (start < end){
            //如果前后相等，交换
            if (set.contains(chars[start]) && set.contains(chars[end])){
                char temp = chars[end];
                chars[end] = chars[start];
                chars[start] = temp;
                start++;
                end--;
            }
            else {
                if (!set.contains(chars[start])){
                    start++;
                }
                else {
                    end--;
                }
            }
        }

        return String.valueOf(chars); 
    }
}
```

<a id="551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95-i"></a>
## 551. 学生出勤纪录 I
类型：字符串
### 题目
给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符：

- 'A' : Absent，缺勤
- 'L' : Late，迟到
- 'P' : Present，到场

如果一个学生的出勤纪录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。

你需要根据这个学生的出勤纪录判断他是否会被奖赏。

### 思路
统计字符串中A 和 L 的个数，如果超过规定，返回 false。

为了保证统计到的 L 是连续的，在统计到 A 和 P 和时候，将 L 的个数清除。

时间效率不高，执行结果如下：
```
113 / 113 个通过测试用例
状态：通过
执行用时：27 ms
```


### 代码
```java
class Solution {
    public boolean checkRecord(String s) {
                if (s.length() == 0 || s==null)
            return true;

        char[] chars =s.toCharArray();
        int  Anum = 0;
        int  Lnum = 0;

        for (int i=0;i<chars.length;){
            if (chars[i] == 'A'){
                Anum++;
                Lnum=0;
                i++;
            }
            //迟到的次数，如何保证验证连续的 L 呢
            else if (chars[i] == 'L'){
                Lnum++;
                i++;
            }
            else{
                i++;
                Lnum =0;
            }
            if (Lnum>2 || Anum>1){
                return false;
            }
        }
        return true;
    }
}
```

<a id="67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"></a>
## 67. 二进制求和
类型：字符串
### 题目
给定两个二进制字符串，返回他们的和（用二进制表示）。
```
案例：
a = "11"
b = "1"
返回 "100" 。
```

### 思路
将字符转换为char数组，并且将char数组翻转，最为依次相加，如果不一样长，短的置位0，进位用 add 表示。

需要再找时间和空间效率更好的 AC 解

执行结果如下：
```
294 / 294 个通过测试用例
状态：通过
执行用时：4 ms
```

### 代码
```java
class Solution {
    public String addBinary(String a, String b) {
               //校验输入
        if (a == null || b == null)
            return "0";

        int aLen = a.length()-1;
        char[] a2char = a.toCharArray();
        reverse(a2char);

        int bLen = b.length()-1;
        char[] b2char = b.toCharArray();
        reverse(b2char);


        //add 表示进位
        int add =0;

        //存结果
        StringBuffer res = new StringBuffer();
        int i =0,j=0;
        for (;i<=aLen||j<=bLen;i++,j++){
            int aValue;
            int bValue;

            if (i>aLen){
                aValue = 0;
            }
            else {
                aValue = a2char[i]-'0';
            }
            if (j>bLen){
                bValue =0;
            }
            else {
                bValue = b2char[j]-'0';
            }
            int temp = aValue + bValue + add;
            res.append(temp%2);
            add = temp/2;
        }


        if (add!=0){
            res.append(add);
        }

        return res.reverse().toString(); 
    }
        private void reverse(char[] chars){
        int start = 0;
        int end = chars.length-1;
        while (start<end){
            char temp = chars[end];
            chars[end] =chars[start];
            chars[start] =temp;
            start++;
            end--;
        }

    }
}

```


<a id="74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"></a>
## 74. 搜索二维矩阵

### 题目
编写一个高效的算法来搜索 m x n 矩阵中的一个目标值。该矩阵具有以下特性：

- 每行中的整数从左到右排序。
- 每行的第一个整数大于前一行的最后一个整数。

例如，

以下矩阵：

```
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
```
给定 目标值= 3，返回 true。

### 思路
二分查找，较简单，从右上角开始查找，如果右上角值比 target 大，去掉一列，否则去掉一行，如果相等，返回true。

```
136 / 136 个通过测试用例
状态：通过
执行用时：10 ms
```

### 代码
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0)
            return false;

        int row = matrix.length-1;    //行
        int col = matrix[0].length-1; //列

        for (int i=0,j=col;i<=row && j>=0;){
            if (matrix[i][j]>target){
                j--;
            }
            else if (matrix[i][j]<target){
                i++;
            }
            else {
                return true;
            }
        }

        return false;
    }
}
```

<a id="153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"></a>
## 153. 寻找旋转排序数组中的最小值

二分查找，中等难度。

###题目
假设一个按照升序排列的有序数组从某未知的位置旋转。

（比如 0 1 2 4 5 6 7 可能变成 4 5 6 7 0 1 2）。

找到其中最小的元素。

你可以假设数组中不存在重复的元素。

### 思路
二分查找，中间值和右边值比较，如果大于右边值，移动 start = middle +1;

如果中间值小于 右边值，移动 end = middle；

AC结果如下：
```
146 / 146 个通过测试用例
状态：通过
执行用时：0 ms
```

### 代码

```java
class Solution {
    public int findMin(int[] nums) {
             if (nums == null || nums.length == 0)
            return 0;

        int start =0;
        int end = nums.length-1;
        if (nums[start]<nums[end])
            return nums[start];
        int middle=0;
        while (start<end){
             middle = start +(end-start)/2; //需要保证不能 int 相加出现溢出

            //让中位数和右边的数字比较
            if (nums[middle]>nums[end]){
                start = middle+1;
            }
            else if (nums[middle]<nums[end]){
                end = middle;
            }
        }

            return nums[start];   
    }
}
```

<a id="2018418"></a>
# 2018.4.18

<a id="541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"></a>
## 541. 反转字符串 II
<font color="red">字符串</font>
### 题目
给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。

**示例:**
```
输入: s = "abcdefg", k = 2
输出: "bacdfeg"
```
**要求:**

- 该字符串只包含小写的英文字母。
- 给定字符串的长度和 k 在[1, 10000]范围内。

### 思路
难点在于判断逻辑，采用取余法。

AC结果如下：
```
60 / 60 个通过测试用例
状态：通过
执行用时：6 ms
```

### 代码
```java
class Solution {
    public String reverseStr(String s, int k) {
                //校验输入
        if (s == null || s.length() == 0)
            return null;

        if (k<=0){
            return s;
        }

        int strLen = s.length();

        char[] chars = s.toCharArray();

        //剩余元素个数
        int remainder = strLen%(2*k);

        //循环的次数
        int times = strLen/(2*k);

        //翻转 times 次
        int start = 0;
        int end =k-1;
        while (times>0){
            reverse(chars,start,end);
            times--;
                start +=2*k;
                end +=2*k;
        }

        if (remainder>=k){
            reverse(chars,start,start+k-1);
        }
        else {
            reverse(chars,start,strLen-1);
        }

        return  String.valueOf(chars);
    }
    
       /**
     * 反转 char 数组中的元素
     * @param chars
     * @param start
     * @param end
     */
    private void reverse(char[] chars ,int start,int end){
        if (chars.length == 0 || chars == null)
            return;
        while (start < end){
            char temp = chars[end];
            chars[end] = chars[start];
            chars[start] = temp;
            start++;
            end--;
        }
    }
}
```

<a id="58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"></a>
## 58. 最后一个单词的长度

<font color="red"> 字符串 </font>

### 题目
给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指由字母组成，但不包含任何空格的字符串。

**示例:**
```
输入: "Hello World"
输出: 5
```

### 思路
正则表达式将字符串分割，然后再判断数组是否为空，如果为空，返回 0 ，否则返回最后一个字符

### 代码

```java
class Solution {
    public int lengthOfLastWord(String s) {
                if (s.length() == 0 || s == null)
            return 0;

        String []  str = s.split(" ");

        if (str.length == 0)
            return 0;

        return str[str.length-1].length();
    }
}


```

<a id="459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"></a>
## 459. 重复的子字符串
<font color="red"> 字符串 </font>

### 题目
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

**示例 1:**
```
输入: "abab"

输出: True
```
解释: 可由子字符串 "ab" 重复两次构成。

**示例 2:**
```
输入: "aba"

输出: False
```

**示例 3:**
```
输入: "abcabcabcabc"

输出: True
```
解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)

### 思路

**解决这道题最好的方法是 KMP，这是模式匹配最快的的算法，复杂度是O(n)。 **

我的思路是：

重复子串长度最长为len/2，直接每次选择一个可以被整除的较小的数，截取开头的那几个字符，然后重复到原长度验证就好。

AC结果（时间性能比较差）
```
107 / 107 个通过测试用例
状态：通过
执行用时：109 ms
```
**参考博客：https://blog.csdn.net/u014248127/article/details/53999633**

**从头到尾彻底理解KMP:https://blog.csdn.net/v_july_v/article/details/7041827**

KMP 算法应该有更深的理解

### 代码

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
                //校验输入
        if (s.length() <= 1 || s == null)
            return false;
        int len = s.length();
        for(int i=1;i<=len/2;i++) {//最大长度
            if(len%i == 0) {
                String tem = s.substring(0, i);//子串
                StringBuffer sb = new StringBuffer();
                for(int j=0;j<len/i;j++) {
                    sb = sb.append(tem);//生成相同长度
                }
                if(sb.toString().equals(s))//验证
                    return true;
            }
        }
        return false;
    }
}
```

<a id="2018419"></a>
# 2018.4.19

<a id="696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2"></a>
## 696. 计数二进制子串
<font color="red">字符串</font>

### 题目
给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**
```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**
```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```
注意：
```
s.length 在1到50,000之间。
s 只包含“0”或“1”字符。
```

### 思路

不会做，主要是没搞明白题目的意图。参考博客： [参考博客1](https://www.cnblogs.com/xiejunzhao/p/7684496.html)， [参考博客2](https://www.cnblogs.com/grandyang/p/7716150.html)

AC结果：
```
90 / 90 个通过测试用例
状态：通过
执行用时：22 ms
```

### 代码
```java
class Solution {
    public int countBinarySubstrings(String s) {
        int prevRunLen = 0;
        int curRunLen = 1;
        int res = 0;

        char[] str = s.toCharArray();

        for (int i=1;i<s.length();i++){
            if (str[i] == str[i-1]){
                curRunLen++;
            }
            else {
                prevRunLen = curRunLen;
                curRunLen =1;
            }
            if (prevRunLen>=curRunLen)
                res++;
        }
        return res;
    }
}
```

<a id="819-most-common-word"></a>
## 819. Most Common Word
<font color="red">字符串</font>

### 题目
Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.

```
Example:
Input: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
```

**Note:**

- 1 <= paragraph.length <= 1000.
- 1 <= banned.length <= 100.
- 1 <= banned[i].length <= 10.
- The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and - even if it is a proper noun.)
- paragraph only consists of letters, spaces, or the punctuation symbols !?',;.
- Different words in paragraph are always separated by a space.
- There are no hyphens or hyphenated words.
- Words only consist of letters, never apostrophes or other punctuation symbols.

### 思路
采用 hashset存储 banned 数组，然后用正则表达式将Str 中的标点符号去除吗，最后用空格将字符串分割为数组。

我的失误点在于正则表达式不会使用

AC结果：
```
46 / 46 个通过测试用例
状态：通过
执行用时：30 ms
```

### 代码

```java
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        //将 banned 数组转换为 Set
        Set<String> ban = new HashSet<>(Arrays.asList(banned));

        Map<String,Integer> count = new HashMap<>();

        // \\pP去除标点符号
        String[] words = paragraph.replaceAll("\\pP","").toLowerCase().split(" ");

        String res = "";

        int max = 0;

        for (String str : words){
            if (!ban.contains(str)){
                count.put(str,count.getOrDefault(str,0)+1);
                if (count.get(str)>max){
                    res = str;
                    max = count.get(str);
                }
            }
        }
        return res;
    }
}
```

<a id="521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%A0"></a>
## 521. 最长特殊序列 Ⅰ
<font color="red">字符串</font>

### 题目
给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。

子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。

输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。

**示例 :**
```
输入: "aba", "cdc"
输出: 3
解析: 最长特殊序列可为 "aba" (或 "cdc")
```
说明:

- 两个字符串长度均小于100。
- 字符串中的字符仅含有 'a'~'z'。

### 思路

理解题意最重要。**只需要判断两字符串是否相等，如果相等就返回-1，不相等就返回较长的字符串长度！**

不过这道题本身有点不太好理解。

AC结果：
```
41 / 41 个通过测试用例
状态：通过
执行用时：2 ms
```

### 代码
```java
class Solution {
    public int findLUSlength(String a, String b) {
        int aLen = a.length();
        int bLen =b.length();

        if (a.equals(b)){
            return -1;
        }

        return aLen>bLen?aLen:bLen;
    }
}
```

<a id="606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"></a>
## 606. 根据二叉树创建字符串

### 题目

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 "()" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

**示例 1:**
```

输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: "1(2(4))(3)"

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
```

**示例 2:**
```
输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: "1(2()(4))(3)"

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
```

### 思路

采用前序遍历，注意区分左右子树是否为空。递归求解。

### 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
        StringBuilder res = new StringBuilder();

    public String tree2str(TreeNode t) {
        if (t == null)
            return "";

        res.append(t.val);

        if (t.left!=null){
            res.append('(');
            tree2str(t.left);
            res.append(')');
        }
        else if (t.right!=null){
            res.append("()");
        }

        if (t.right!=null){
            res.append('(');
            tree2str(t.right);
            res.append(')');
        }

        return res.toString();
    }
}
```
<a id="434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0"></a>
## 434. 字符串中的单词数

<a id="%E9%A2%98%E7%9B%AE"></a>
### 题目
统计字符串中的单词个数，这里的单词指的是连续的非空字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:
```
输入: "Hello, my name is John"
输出: 5
```

### 思路
- 首先判断字符长度，以及去掉两端空格之和的长度
- 判断字符是否只有一个字段
- 如果当前为空格，下一个字符不为空格

### 代码
```java

class Solution {
    public int countSegments(String s) {
        //如果字符长度为0，或者只包含空格，返回 0
        if (s.length() == 0||s.trim().isEmpty())
            return 0;

        String str = s.trim();

        int res = 0;

        if (str.length()==1){
            return 1;
        }

        for (int i=0;i<str.length();i++){
            if (str.charAt(i) == ' ' && str.charAt(i+1) != ' ')
                res++;
        }

        if (res == 0){
            return 1;
        }
        else {
            return res+1;
        }

    }
}
```

<a id="287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"></a>
## 287. 寻找重复数

### 题目
一个长度为 n + 1 的整形数组，其中的数字都在 1 到 n 之间，包括 1 和 n ，可知至少有一个重复的数字存在。假设只有一个数字重复，找出这个重复的数字。

注意：

- 不能更改数组内容（假设数组是只读的）。
- 只能使用恒定的额外空间，即要求空间复杂度是 O(1) 。
- 时间复杂度小于 O(n2)
- 数组中只有一个数字重复，但它可能不止一次重复出现。

### 思路

1） hashset 或 hashmap ，但是不符合空间复杂度要求

2） 暴力法，双重for循环

3）二分查找 (二分查找)[https://blog.csdn.net/jmspan/article/details/51158516]

4）更快的方法，使用双指针，不过有点难理解。但是时间复杂度相当低

AC结果如下：
```
53 / 53 个通过测试用例
状态：通过
执行用时：5 ms
```


### 代码
```java
class Solution {
    public int findDuplicate(int[] nums) {
                int high = nums.length-1;
        int low = 0;

        while (high>=low){
            int middle = low +(high-low)/2;
            int count = 0;
            for (int i=0;i<nums.length;i++){
                if (nums[i]<=middle){
                    count++;
                }
            }
            //如果满足，说明 1-middle 之间有重复数字
            if (count>middle)
                high = middle-1;
            else
                low=middle+1;
        }

        return low;
    }
}

```

<a id="209-%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%92%8C%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"></a>
## 209. 大于给定和最短子数组

### 题目
```
给定一个含有 n 个正整数的数组和一个正整数 s , 找到一个最小的连续子数组的长度，使得这个子数组的数字和 ≥  s 。如果不存在符合条件的子数组，返回 0。

举个例子，给定数组 [2,3,1,2,4,3] 和 s = 7,
子数组 [4,3]为符合问题要求的最小长度。

```


### 思路

双指针，对快慢指针的中间数组求和，根据和的反馈修改指针位置.

思路与最快AC结果是相符合的，但是形式不对，算法有很大的优化空间。

AC结果：时间性能差到爆炸
```
15 / 15 个通过测试用例
状态：通过
执行用时：117 ms
```


### 代码

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
               if (nums.length == 0 || nums == null)
            return 0;

        int slow = 0;
        int fast = 0;

        int sum = 0;

        int res =Integer.MAX_VALUE;

        while (fast<nums.length){
            sum = sum(nums,slow,fast);
            if (sum<s){
                fast++;
            }
            else if (sum>s){//要是第一个就大于s呢，

                int temp = fast-slow+1;
                //取最小值
                if (temp<res)
                    res=temp;

                slow++;

            }
            else {
                int temp = fast-slow+1;
                fast++;
                //取最小值
                if (temp<res)
                    res=temp;
            }
        }
        if (res == Integer.MAX_VALUE)
            res =0;

        return res; 
    }
    private int sum(int[]nums,int start,int end){
    if (nums.length == 0 || start>end)
        return 0;
    int sum =0;
    for (int i=start;i<=end;i++){
        sum +=nums[i];
    }
    return sum;
}
}
```

<a id="485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"></a>
## 485. 最大连续1的个数
### 题目
给定一个二进制数组， 计算其中最大连续1的个数。

**示例 1:**
```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```

注意：

- 输入的数组只包含 0 和1。
- 输入数组的长度是正整数，且不超过 10,000。

<a id="%E6%80%9D%E8%B7%AF"></a>
### 思路

逐个判断 0 和 1 ，遇上0 的时候，对比找出最大值并保存。

AC结果：
```
41 / 41 个通过测试用例
状态：通过
执行用时：7 ms
```

<a id="%E4%BB%A3%E7%A0%81"></a>
### 代码
```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
              if (nums.length == 0 || nums == null)
            return 0;

        int res = 0;

        int temCount = 0;

        for (int i=0;i<nums.length;i++){
            if (nums[i] == 1)
                temCount++;
            else if (nums[i] == 0){
                if (temCount>res)
                    res=temCount;
                temCount=0;
            }
        }
         return temCount>res?temCount:res; 
    }
}
```

<a id="566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5"></a>
## 566. 重塑矩阵
### 题目
在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

示例 1:
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```
示例 2:
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
```
注意：

- 给定矩阵的宽和高范围在 [1, 100]。
- 给定的 r 和 c 都是正数。

### 思路

1）采用链表保存遍历原数组的结果，再依次遍历新数组并往其中添加元素

2）采用最简洁的方法，依次从左到右遍历数组，在遍历的过程中添加。nums[i/col][i%col],其中i<row*col;

AC结果：
```

56 / 56 个通过测试用例
状态：通过
执行用时：9 ms
```

### 代码
```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
       int[][] res = new int[r][c];

        if (nums.length == 0 || nums[0].length ==0)
            return res;
        int rows = nums.length;
        int cols = nums[0].length;

        if (rows*cols != r*c){
            return nums;
        }
        else {
            for (int i=0;i<r*c;i++){
                //将两个数组从左往右依次遍历
                res[i/c][i%c] = nums[i/cols][i%cols];
            }
        }
        return res; 
    }
}
```

```java
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
   int[][] res = new int[r][c];
 
         if (nums.length == 0 || nums[0].length ==0)
             return res;
         int rows = nums.length;
         int cols = nums[0].length;
 
         if (rows*cols != r*c){
             return nums;
         }
         else {
             List<Integer> list = new ArrayList<>();
             for (int i=0;i<rows;i++){
                 for (int j=0;j<cols;j++){
                     list.add(nums[i][j]);
                 }
             }
 
             int index =0;
             for (int i=0;i<r;i++){
                 for (int j=0;j<c;j++){
                     res[i][j] = list.get(index);
                     index++;
                 }
             }
         }
         return res;
    }
}
```
<a id="383-%E8%B5%8E%E9%87%91%E4%BF%A1"></a>
## 383. 赎金信

### 题目
给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)

注意：

你可以假设两个字符串均只含有小写字母。
```
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
```

### 思路

1）建立两个 长度为 26 的数组哈希表，统计两个串中字符出现次数。然后对比

2）建立一个哈希表，一个加，一个减，出现负数则说明匹配不上


### 代码

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
          //自建哈希表
        int[] map = new int[26];   //存储 magazine 字符出现频次

        for (char c:magazine.toCharArray()
             ) {
            map[c-'a'] +=1;
        }

        for (char c:ransomNote.toCharArray()
             ) {
            map[c-'a'] -=1;
            //如果小于 0，两种情况：1）小于magazine该字符的数量，2)在magazine没有这个字符
            if (map[c-'a']<0)
                return false;
        }
        return true; 
    }
}
```


```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        //校验输入

        //全部由小写字母组成，自建哈希表

        int[] map1 = new int[26];   //存储 magazine 字符出现频次
        int[] map2 = new int[26];   //存储 ransomNote 字符出现频次

        for(int i=0;i<magazine.length();i++){
            map1[magazine.charAt(i)-'a'] +=1;
        }

        for (int i=0;i<ransomNote.length();i++){
            map2[ransomNote.charAt(i)-'a'] +=1;
        }

        for (int i=0;i<map1.length;i++){
            if (map1[i]<map2[i])
                return false;
        }

        return true;
    }
}
```
<a id="28-%E5%AE%9E%E7%8E%B0strstr"></a>
## 28. 实现strStr()

### 题目
实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:
```
输入: haystack = "hello", needle = "ll"
输出: 2

```
示例 2:
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

说明:

- 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

- 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

### 思路
1）双指针：注意逻辑处理

2）KMP


### 代码
```java
class Solution {
    public int strStr(String haystack, String needle) {
                int m = haystack.length();
        int n = needle.length();
        for (int i=0;i<=m-n;i++){
            int j;
            for (j=0;j<n;j++){
                if (haystack.toCharArray()[i+j] != needle.toCharArray()[j]){
                    break;
                }
            }
            if (j==n)
                return i;
        }
        return -1;
    }
}
```
<a id="2018424"></a>
# 2018.4.24

<a id="154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-ii"></a>
## 154. 寻找旋转排序数组中的最小值 II

### 题目

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]）。

找到其中最小的元素。

注意数组中可能存在重复的元素。

示例 1:
```
输入: [1,3,5],
输出: 1
```

示例 2:
```
输入: [2,2,2,0,1],
输出: 0
```

### 思路

需要在无重复的旋转数组中注意一个地方：在middle 和 end 相等的时候，让 end 自减 1 即可；

### 代码
```java
class Solution {
    public int findMin(int[] nums) {
               if (nums == null || nums.length == 0)
            return 0;

        int start =0;
        int end = nums.length-1;
        //第一个数小于最后一个数，说明是完全升序
        if (nums[start]<nums[end])
            return nums[start];

        int middle=0;
        while (start<=end){
             middle = start +(end-start)/2; //需要保证不能 int 相加出现溢出

            //让中位数和右边的数字比较
            if (nums[middle]>nums[end]){
                start = middle+1;
            }
            //如果 end = middle-1 的话，不能通过 {3,1,2}
            else if (nums[middle]<nums[end]){
                end = middle;//因为这里的 end 可能就是最小值，不能加一
            }
            //如果中间和最后相等。怎么查找，主要前后移动方向不确定
            //无法确定的时候，让 右边的值自减就好了
            else {
                end--;
            }
        }
            return nums[start]; 
    }
}
```
<a id="27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"></a>
## 27. 移除元素

#### 题目
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1:
```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```

示例 2:
```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```

### 思路

双指针

### 代码

```java
class Solution {
    public int removeElement(int[] nums, int val) {
                int n=nums.length;
        int i=0;
        while(i<n){
            if(nums[i]==val){
                n--;
                nums[i]=nums[n];
            } else{
                i++;
            }
        }
        return n;
    }
}
```

<a id="141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"></a>
## 141. 环形链表

### 题目
给定一个链表，判断链表中是否有环。

进阶：

你能否不使用额外空间解决此题？

### 思路
1) 采用额外空间，使用 hashset

2）采用快慢指针

### 代码

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
                if(head == null)
            return false;

        HashSet<ListNode> set = new HashSet<>();
        
        while (head!=null){
            
            if (set.contains(head)){
                return true;
            }
            else {
                set.add(head);
                head = head.next;
            }
        }
        return false;
    }
}
```

### 代码
采用双指针查找,时间性能更好
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
         if(head == null)
        return false;

        ListNode slowIndex = head;
        ListNode fastIndex =head;

        while (fastIndex!= null && fastIndex.next !=null){
            slowIndex = slowIndex.next;
            fastIndex =fastIndex.next.next; //如果当前节点数不足的话，最终会指向 null

            if (slowIndex == fastIndex){
                return true;
            }
        }
        return false;   
    }
}
```
<a id="142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii"></a>
## 142. 环形链表 II

### 题目
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

说明：不允许修改给定的链表。

进阶：

你是否可以不用额外空间解决此题？

### 思路

1）采用 hashset ，返回第一个重复出现的节点

2） 采用双支针，出现重复之后，慢指针返回到头结点，快指针继续，两者每次都走一步，直到相遇


### 代码

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
              if (head == null || head.next ==null)
            return null;

        ListNode slowIndex = head;
        ListNode fastIndex = head;

        while (fastIndex != null && fastIndex.next != null){
            slowIndex =slowIndex.next;
            fastIndex =fastIndex.next.next;

            if (slowIndex == fastIndex){
                slowIndex = head;

                while (slowIndex != fastIndex){
                    slowIndex = slowIndex.next;
                    fastIndex =fastIndex.next;
                }
                return slowIndex;
            }
        }
        return null;  
    }
}
```
<a id="2018425"></a>
# 2018.4.25
<a id="%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9-ii"></a>
##  从排序数组中删除重复项 II

### 题目 

数组中的元素最多允许重复两次

### 思路

采用 count 计数，如果 count >2 跳过；否者存储元素

### 代码

```java
public class Solution {
 public int removeDuplicates_2(int[] nums) {

        if (nums.length == 0)
            return 0;

        int idx =0;
        int count =0;

        for (int i=0;i<nums.length;i++){
            if (i>0 && nums[i] == nums[i-1]){
                count++;
                if (count>2){/**说明重复数超过2个*/
                    continue;//继续执行for循环，避免使用break
                }

            }
            else {/**如果出现不同，将 count 赋值为1*/
                count=1;
            }/** idx 为去重之后的数组索引*/
            nums[idx] = nums[i];
            idx++;

        }


        return idx;
    }
    }
```

<a id="763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"></a>
## 763. 划分字母区间

### 题目
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。

**示例 1:**
```
输入: S = "ababcbacadefegdehijhklij"
输出: [9,7,8]
解释:
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```

**注意:**

- S的长度在[1, 500]之间。
- S只包含小写字母'a'到'z'。

### 思路
参考博客：http://www.cnblogs.com/grandyang/p/8654822.html

一旦某个字母多次出现了，那么其最后一个出现位置必须要在当前子串中，字母a，e，和j，分别是三个子串中的结束字母。
所以我们关注的是每个字母最后的出现位置，我们可以使用一个HashMap来建立字母和其最后出现位置之间的映射.

双指针：
建立好映射之后，就需要开始遍历字符串S了，我们维护一个start变量，是当前子串的起始位置，还有一个last变量，
是当前子串的结束位置，每当我们遍历到一个字母，我们需要在HashMap中提取出其最后一个位置，
因为一旦当前子串包含了一个字母，其必须包含所有的相同字母，所以我们要不停的用当前字母的最后一个位置来更新last变量，
只有当i和last相同了，即当i = 8时，当前子串包含了所有已出现过的字母的最后一个位置，即之后的字符串里不会有之前出现过的字母了，
此时就应该是断开的位置，我们将长度9加入结果res中，同理类推，我们可以找出之后的断开的位置

### 代码
```java
class Solution {
    public List<Integer> partitionLabels(String S) {
         List<Integer> res = new ArrayList<>();
        //校验输入
        if (S == null)
            return res;
      //  HashMap<Character,Integer> map = new HashMap<>();

        //自建 哈希表
        int[] map = new int[26];

        /**添加到 hashmap 中，记录每个元素的最后出现位置*/
        for (int i=0;i<S.length();i++){
          //  map.put(S.charAt(i),i);
            map[S.charAt(i)-'a'] =i;
        }

        int start =0;
        int last=0;

        for (int i=0;i<S.length();i++){
            //在便利过程中，取 last 的最大值
            last = Math.max(last,map[S.charAt(i)-'a']);
            if (i==last){
                res.add(i-start+1);
                start = i+1;
            }
        }
        return res;  
    }
}
```

<a id="56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"></a>
## 56. 合并区间


<a id="713-subarray-product-less-than-k"></a>
## 713. Subarray Product Less Than K

### 题目

Your are given an array of positive integers nums.

Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.

**Example 1:**

```
Input: nums = [10, 5, 2, 6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

```

**Note:** 

- 0 < nums.length <= 50000.
- 0 < nums[i] < 1000.
- 0 <= k < 10^6.

### 思路

参考博客：https://www.cnblogs.com/grandyang/p/7753959.html

因为是连续子数组，所以不能采取排序解决。

涉及一种滑动窗口的思想。

所以窗口每次向右增加一个数字，然后左边去掉需要去掉的数字后，窗口的大小就是新的子数组的个数


### 代码

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (nums.length == 0 || k<=1)
            return 0;

        int n = nums.length; //数组长度

        long p = 1l;    //保存中间结果，防止溢出

        int left=0,total =0;

        for (int j=0;j<n;j++){
            p *= nums[j];
            while (p>= k){
                p /= nums[left];
                left++;
            }
            total += (j-left+1); //滑动窗口的大小就是当前子数组的个数
        }

        return total;   
    }
}
```

### 思考

1）如果给的数组中包含了负数和零？

2）求的不是子数组，而是子序列，如何解？

<a id="2018426"></a>
# 2018.4.26
<a id="617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"></a>
## 617. 合并二叉树

### 题目
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:
```
输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  

输出:
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
```
注意: 合并必须从两个树的根节点开始。

### 思路

递归的思想，从根节点开始遍历，递归左右子树.

参考博客1：https://blog.csdn.net/qq_26658823/article/details/73825029
参考博客2：https://blog.csdn.net/LITTENg/article/details/80037515


### 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
              if (t1 == null && t2 == null)
            return null;
        else if (t1 == null)
            return t2;
        else if (t2 == null)
            return t1;
        else {
            t1.val += t2.val;
            t1.left = mergeTrees(t1.left,t2.left);
            t1.right = mergeTrees(t1.right,t2.right);
            return t1;
        }  
    }
}
```
<a id="441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81"></a>
## 441. 排列硬币

### 题目
你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。

给定一个数字 n，找出可形成完整阶梯行的总行数。

n 是一个非负整数，并且在32位有符号整型的范围内。

示例 1:
```
n = 5

硬币可排列成以下几行:
¤
¤ ¤
¤ ¤

因为第三行不完整，所以返回2.
```
示例 2:
```
n = 8

硬币可排列成以下几行:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

因为第四行不完整，所以返回3.

```

### 思路
1）二分查找
2）数学法

### 代码
```java
class Solution {
    public int arrangeCoins(int n) {
             if (n<=0)
            return 0;

        int start =0;
        int end =n;

        while (start <= end){
            int middle = start +(end-start)/2;

            int sum = middle*(middle+1)/2;

            if (sum>n){
                end = middle-1;
            }
            else if (sum<=n){
                start = middle+1;
            }

        }
        return start-1;
    }
}
```

## 454. 四数相加 II 4Sum II

### 题目
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
例如:
````
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
````


### 思路

将四个数组拆分为两个两个数组，采用 分别求和的方式，最和在合并.

参考博客：https://blog.csdn.net/MebiuW/article/details/53192762

### 代码

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
             if (A.length == 0)
            return 0;

        HashMap<Integer,Integer> map = new HashMap<>();

        for (int a :
                A) {
            for (int b :
                    B) {/**如果存在了，则加一个1，否者，存为1*/
                map.put(a + b, map.getOrDefault(a + b, 0) + 1);
            }
        }

        int res =0;
        for (int c :
                C) {
            for (int d:D
                 ) {
                int part1 = c+d;
                int part2 = -part1;/**在 map 中去查找相反数，如果没有，为0即可*/
                res += map.getOrDefault(part2,0);
            }
        }


        return res;
    }
}
```

## SUM 问题总结



